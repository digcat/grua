#!/usr/bin/env python
import shutil
import yaml, os.path, sys, time, subprocess, shlex, re
from collections import deque
from subprocess import call

Project = 'grua'  # gets replaced by 'project' value in 'global' from grua.yaml

def announce(msg):
    print "\n\t>>> " + msg + "\n"

def find_bridge_ip():
    command = ["ip", "addr", "show", "dev", "docker0"]
    sp = subprocess.Popen((command), stdout=subprocess.PIPE)
    output = subprocess.check_output(('grep', 'inet'), stdin=sp.stdout).strip().split()[1].split('/')[0]

    sp.wait()

    # ensure we have a valid ip
    p = re.compile(
        '^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$')
    if not p.match(output):
        raise Exception(output + " is not a valid IP address for BridgeIP")

    return output


BridgeIp = find_bridge_ip()


# http://stackoverflow.com/a/11564323
def topological_sort(source):
    """perform topo sort on elements.

  :arg source: list of ``(name, [list of dependencies])`` pairs
  :returns: list of names, with dependencies listed first
  """
    pending = [(name, set(deps)) for name, deps in source]  # copy deps so we can modify set in-place
    emitted = []
    while pending:
        next_pending = []
        next_emitted = []
        for entry in pending:
            name, deps = entry
            deps.difference_update(emitted)  # remove deps we emitted last pass
            if deps:  # still has deps? recheck during next pass
                next_pending.append(entry)
            else:  # no more deps? time to emit
                yield name
                emitted.append(name)  # <-- not required, but helps preserve original ordering
                next_emitted.append(name)  # remember what we emitted for difference_update() in next pass
        if not next_emitted:  # all entries have unmet deps, one of two things is wrong...
            raise ValueError("cyclic or missing dependency detected: %r" % (next_pending,))
        pending = next_pending
        emitted = next_emitted


deps = dict()


def inspect_container(container, go_template):
    print go_template
    command = ['docker', 'inspect', '-f', '"' + (" ").join(go_template) + '"', Project + "_" + container]

    return subprocess.check_output(command, stderr=subprocess.STDOUT)

def tpl_lookup(template):
    words = template.split()
    selecta = words[0]

    words.pop(0)

    if selecta == "ENV":
        return os.environ.get(words[0], '')

    if selecta == "INSPECT":
        container = words[0]
        words.pop(0)
        return inspect_container(container, words)

    if selecta == "GRUA":
        key = words[0]
        words.pop(0)
        if key == 'BRIDGE_IP':
            return BridgeIp


def parse_template(tpl):
    a1 = str(tpl).split("<%")
    out = ''
    for i in range(0, len(a1)):
        if i % 2 == 1:  # odd, replace template
            a2 = a1[i].split("%>")
            if len(a2) > 1:
                out += tpl_lookup(a2[0].strip())
                out += a2[1]
            else:
                out += a2[0]
        else:  # even, use directly
            out += a1[i]

    return out


def get_value(dict, key):
    if not dict.has_key(key):
        return ''
    return parse_template(dict[key])


def calc_deps(container, config):
    for key in config[container]:
        if not deps.has_key(container):
            deps[container] = []
        val = config[container][key]
        if key == "before":
            for before in val:
                if before not in deps:
                    deps[before] = [container]
                else:
                    deps[before].append(container)

        if key == "after":
            if container not in deps:
                deps[container] = val
            else:
                for after in val:
                    if after not in deps[container]:
                        deps[container].append(after)


def process_container(container, config):
    calc_deps(container, config)


def stack_container(container, config):
    announce("Stacking "  + container)
    if config.has_key('build'):
        tag = Project + "/" + container
        if config.has_key('tag'):
            tag = get_value(config, 'tag')

        build = get_value(config, 'build')
        target = build
        if build[:4] == 'git:':
            if not config.has_key('tag'):
                raise Exception("If you are using a git repo for 'build' you must also specify 'tag'")
            tag = get_value(config,'tag')

            url = build[4:]
            print "Cloning " + tag + " from " + url
            dir = "_grua_" + tag.replace("/", "_")

            if os.path.isdir(dir):
                shutil.rmtree(dir)

            call(['git', 'clone', url, dir])
            target = dir

        print "building " + container + " ( " + target + " ) " + " with tag '" + tag + "'"
        call(['docker', 'build', '-t', tag, target])
    else:
        print container + " uses an image. Pulling " + get_value(config, 'image')
        call(['docker', 'pull', get_value(config, 'image')])


def wait_for_up(container, config):
    upwhen = config['upwhen']
    timeout = 30
    if upwhen.has_key('timeout'):
        timeout = get_value(upwhen, 'timeout')

    print "timeout=" + str(timeout)

    if upwhen.has_key('logmsg'):
        logmsg = get_value(upwhen, 'logmsg')

    print "Waiting for '" + logmsg + "' to indicate that " + container + " is up"
    waited = 0
    ok = False
    while waited <= timeout:
        command = ["docker", "logs", Project + "_" + container]
        output = subprocess.check_output(command, stderr=subprocess.STDOUT)
        if output.find(logmsg) > 0:
            ok = True
            break
        else:
            time.sleep(1)
            waited = waited + 1

    if upwhen.has_key('sleep'):
        print "Sleeping " + str(upwhen['sleep']) + " extra seconds as configured"
        time.sleep(int(upwhen['sleep']))

    if not ok:
        raise Exception("Timed out waiting for " + container + " to start")


def get_image(config):
    if config.has_key('image'):
        image = get_value(config, 'image')  # .split(':')[0]
    elif config.has_key('tag'):
        image = get_value(config, 'tag')
    else:
        image = Project + '/' + get_value(config, 'build')

    return image


def load_container(container, config):
    if config.has_key('run') and not config['run']:
        print "container has 'run' key set to " + str(config['run']) + ", skipping"
        return

    command = ['docker', 'run', '-d', '--name', Project + "_" + container]

    if config.has_key('hostname'):
        command = command + ['--hostname', get_value(config, 'hostname')]

    if config.has_key('dns'):
        command = command + ['--dns', get_value(config, 'dns')]

    if config.has_key('volumes'):
        for volumespec in config['volumes']:
            command = command + ['-v', parse_template(volumespec)]

    if config.has_key('ports'):
        for portspec in config['ports']:
            command = command + ['-p', parse_template(portspec)]

    if config.has_key('environment'):
        for envvar in config['environment']:
            command = command + ['-e', parse_template(envvar) + '=' + parse_template(config['environment'][envvar])]

    if config.has_key('options'):
        for option in config['options']:
            command = command + [parse_template(option)]

    if config.has_key('link'):
        for link in config['link']:
            command = command + ["--link=" + Project + "_" + parse_template(link)]

    command.append(get_image(config))

    if config.has_key('command'):
        command = command + shlex.split(get_value(config, 'command'))

    print "-- " + " ".join(command)
    call(command)

    if config.has_key('upwhen'):
        wait_for_up(container, config)


def unload_container(container):
    call(['docker', 'rm', '--force', Project + '_' + container])


def container_status(container):
    output = subprocess.check_output(['docker', 'inspect', '--format="{{.State.Status}}"', Project + '_' + container],
                                     stderr=subprocess.STDOUT)
    print(Project + '_' + container + ": " + output),


def remove_image(container, config):
    call(['docker', 'rmi', get_image(config)])


def process_command(command_list):
    commands = deque(command_list)

    command = commands.popleft()

    if len(commands) > 0:
        which = [commands.popleft()]
    else:

        deps = sorted_run_deps
        deps.remove('global')
        which = deps
    if command == 'stack':
        for container in which:
            stack_container(container, config[container])

    elif command == 'load':
        for container in which:
            if config[container].has_key('run') and not config[container]['run']:
                pass
            else:
                load_container(container, config[container])

    elif command == 'unload':
        for container in which:

            if config[container].has_key('run') and not config[container]['run']:
                pass
            else:
                unload_container(container)

    elif command == 'reload':
        for container in which:

            if config[container].has_key('run') and not config[container]['run']:
                pass
            else:
                unload_container(container)
                load_container(container, config[container])

    elif command == "status":
        for container in which:
            if config[container].has_key('run') and not config[container]['run']:
                pass
            else:
                container_status(container)

    elif command == "rmi":
        for container in which:
            remove_image(container, config[container])

    else:
        raise Exception("Unknown command '" + command + "'")


def sort_containers():
    tups = list()
    for dep in deps.keys():
        tups.append((dep, deps[dep]))

    s = topological_sort(tups)

    sorted = list();
    for dummy in deps:
        sorted.append(s.next())
    return sorted


def find_yaml_location():
    pathname = os.path.curdir
    while pathname != '/':
        if os.path.isfile(pathname + '/grua.yaml'):
            return pathname
        pathname = os.path.abspath(os.path.join(pathname, os.pardir))

    raise (IOError("grua.yaml file not found"))


def usage():
    print "\tgrua\n\t----\n"
    print "\tgrua stack\tBuild requisite containers"
    print "\tgrua load\tRun container composition"
    print "\tgrua unload\tStop and remove container composition"
    print "\tgrua reload\tUnload and reload container composition"

    print


yamlpath = find_yaml_location()

os.chdir(yamlpath)

with open(yamlpath + "/grua.yaml", 'r') as stream:
    config = yaml.load(stream)
    if config.has_key('global'):
        if config['global'].has_key('project'):
            Project = config['global']['project']
    for container in config:
        process_container(container, config)

sorted_run_deps = sort_containers()
args = sys.argv[1:]

if len(args) > 0:
    process_command(args)
else:
    usage()
